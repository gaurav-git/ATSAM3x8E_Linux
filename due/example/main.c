#include "printf_lite.h"
#include "USB_API.h"
#include "USBCore.h"
#include "USBDesc.h"
#include "PluggableUSB.h"

#ifndef USE_PWM_TC0

void led_set(void) {
	PIOB->PIO_SODR = PIO_PB27;
}
void led_clr(void) {
	PIOB->PIO_CODR = PIO_PB27;
}
void blink_led(int n) {

	int i = 0;

	for (i = 0; i <= n; i++) {
		Sleep(250);
		if (PIOB->PIO_ODSR & PIO_PB27) {
			/* Set Clear register */
			led_clr();
		}
		else {
			/* Set the Set register */
			led_set();
		}
	}
	led_clr();
}
/**
 * Simply blink the amber LED on the DUE with 2Hz:
 */
int main(void) {

	extern struct USBDevice_ USBDevice;
	extern struct Serial_ SerialUSB;
	uint8_t buff[512]= { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
						0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
						0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
						0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
						0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c,
						0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65,
						0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
						0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
						0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
						0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
						0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92,
						0x93, 0x94, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
						0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
						0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
						0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
						0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
						0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
						0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
						0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
						0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
						0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
						0x91, 0x92, 0x93, 0x94, 0x30, 0x31, 0x32, 0x33, 0x34,
						0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d,
						0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
						0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
						0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
						0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61,
						0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
						0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
						0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c,
						0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,
						0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
						0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x30, 0x31, 0x32,
						0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
						0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44,
						0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
						0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
						0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
						0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
						0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,
						0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
						0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
						0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
						0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x30,
						0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
						0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42,
						0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
						0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,
						0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
						0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
						0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
						0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
						0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81,
						0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
						0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
						0x94, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36 };
//	int rx_byte;
	/* The general init (clock, libc, watchdog ...) */
	init_controller();

	/* Board pin 13 == PB27 */
	PIO_Configure(PIOB, PIO_OUTPUT_1, PIO_PB27, PIO_DEFAULT);
	printf_lite_init();
	printf_lite("Hello Xebrium!!\r\n\0");

	USBDevice_Init();

	if(USBDevice.attach()) {
		printf_lite("Device Attached Successfully\r\n\0");
	}
	/* Main loop */

	while (1) {
//		available = SerialUSB.available();
//		printf_lite("Available %u\r\n", available);
//		if (available) {
//			rx_byte = SerialUSB.read();
//			printf_lite("Byte %c\r\n", rx_byte);
//			SerialUSB.write_byte((unsigned char)rx_byte);
			SerialUSB.write(buff, 64);
//		}
	}
	return 0;
}

#else

/*
 * The Arduino DUE LED is on pin 13 on the board, that is PB27 on the chip,
 * which has the timer/counter I/O TIOB0 alternative. Atmel defines for this
 * are PIO_PB27, PIO_PB27B_TIOB0 (Port B 27, Timer I/O B channel 0).
 */
int main(void)
{
  /* The general init (clock, libc, watchdog disable) */
  init_controller();

  /* Use Timer/Counter 0 (enable its clock) */
  pmc_enable_periph_clk(ID_TC0);
  #define LED_CH (0)
  #define TC0_PERIOD (0xffff)

  /* Configure as PWM using upward counter */
  TC_Configure(TC0, LED_CH, 0   /* Channel 0 on TC0                           */
    |TC_CMR_TCCLKS_TIMER_CLOCK2 /* Use TCLK2 as source === MCLK/8             */
    |TC_CMR_WAVE                /* Waveform mode ("PWM")                      */
    |TC_CMR_WAVSEL_UP_RC        /* Count upwards to register C (==RC)         */
    |TC_CMR_BCPB_CLEAR          /* Switch TIOB off when reaching RB Compare   */
    |TC_CMR_BCPC_SET            /* Switch TIOB on  when reaching RC Compare   */
    |TC_CMR_EEVT_XC0
  );

  PIO_Configure(PIOB, PIO_PERIPH_B, PIO_PB27B_TIOB0, PIO_DEFAULT);
  TC_SetRC(TC0, LED_CH, TC0_PERIOD);/* Period: CLK/65536 == 10Hz              */
  TC_SetRB(TC0, 0, 0);              /* Initial duty cycle: 0                  */
  TC_Start(TC0, LED_CH);            /* Start timer (for channel 0)            */

  /* Main loop */
  int16_t d = 1;
  int16_t duty_cycle = 25;

  while(1) {
    Sleep(25);
    duty_cycle += d;
    if(duty_cycle >= 48 || duty_cycle <= 2) d = -d;
    TC_SetRB(TC0, 0, duty_cycle * TC0_PERIOD / 50);
  }
  return 0;
}

#endif
